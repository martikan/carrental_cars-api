// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: car.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createCar = `-- name: CreateCar :one
INSERT INTO cars (brand_id, color, "serial", comfort)
VALUES ($1, $2, $3, $4)
RETURNING id, brand_id, color, serial, comfort, available, created_at
`

type CreateCarParams struct {
	BrandID int64  `json:"brand_id"`
	Color   string `json:"color"`
	Serial  string `json:"serial"`
	Comfort string `json:"comfort"`
}

func (q *Queries) CreateCar(ctx context.Context, arg CreateCarParams) (Car, error) {
	row := q.queryRow(ctx, q.createCarStmt, createCar,
		arg.BrandID,
		arg.Color,
		arg.Serial,
		arg.Comfort,
	)
	var i Car
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Color,
		&i.Serial,
		&i.Comfort,
		&i.Available,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCar = `-- name: DeleteCar :exec
DELETE FROM cars WHERE id = $1
`

func (q *Queries) DeleteCar(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteCarStmt, deleteCar, id)
	return err
}

const getAllCars = `-- name: GetAllCars :many
SELECT c.id
      ,c.brand_id
      ,b.name brand_name
      ,c.color
      ,c.serial
      ,c.comfort
      ,c.available
      ,c.created_at
FROM cars c
INNER JOIN brands b ON c.brand_id = b.id
LIMIT $1
OFFSET $2
`

type GetAllCarsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllCarsRow struct {
	ID        int64     `json:"id"`
	BrandID   int64     `json:"brand_id"`
	BrandName string    `json:"brand_name"`
	Color     string    `json:"color"`
	Serial    string    `json:"serial"`
	Comfort   string    `json:"comfort"`
	Available bool      `json:"available"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) GetAllCars(ctx context.Context, arg GetAllCarsParams) ([]GetAllCarsRow, error) {
	rows, err := q.query(ctx, q.getAllCarsStmt, getAllCars, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCarsRow
	for rows.Next() {
		var i GetAllCarsRow
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.BrandName,
			&i.Color,
			&i.Serial,
			&i.Comfort,
			&i.Available,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCarById = `-- name: GetCarById :one
SELECT c.id
      ,c.brand_id
      ,b.name brand_name
      ,c.color
      ,c.serial
      ,c.comfort
      ,c.available
      ,c.created_at
FROM cars c
INNER JOIN brands b ON c.brand_id = b.id
WHERE c.id = $1
LIMIT 1
`

type GetCarByIdRow struct {
	ID        int64     `json:"id"`
	BrandID   int64     `json:"brand_id"`
	BrandName string    `json:"brand_name"`
	Color     string    `json:"color"`
	Serial    string    `json:"serial"`
	Comfort   string    `json:"comfort"`
	Available bool      `json:"available"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) GetCarById(ctx context.Context, id int64) (GetCarByIdRow, error) {
	row := q.queryRow(ctx, q.getCarByIdStmt, getCarById, id)
	var i GetCarByIdRow
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.BrandName,
		&i.Color,
		&i.Serial,
		&i.Comfort,
		&i.Available,
		&i.CreatedAt,
	)
	return i, err
}

const searchCars = `-- name: SearchCars :many
SELECT c.id
      ,c.brand_id
      ,b.name brand_name
      ,c.color
      ,c.serial
      ,c.comfort
      ,c.available
      ,c.created_at
FROM cars c
INNER JOIN brands b ON c.brand_id = b.id
WHERE ($1::bool IS NULL OR $1::bool = c.available) AND
      (($2::varchar IS NULL) OR
      (LOWER(b.name) LIKE LOWER($2::varchar) || '%') OR
      (LOWER(c.color) LIKE LOWER($2::varchar) || '%') OR
      (LOWER(c.serial) LIKE LOWER($2::varchar) || '%') OR
      (LOWER(c.comfort) LIKE LOWER($2::varchar) || '%'))
LIMIT $4::int
OFFSET $3::int
`

type SearchCarsParams struct {
	AvailableParam sql.NullBool   `json:"available_param"`
	QParam         sql.NullString `json:"q_param"`
	OffsetParam    int32          `json:"offset_param"`
	LimitParam     int32          `json:"limit_param"`
}

type SearchCarsRow struct {
	ID        int64     `json:"id"`
	BrandID   int64     `json:"brand_id"`
	BrandName string    `json:"brand_name"`
	Color     string    `json:"color"`
	Serial    string    `json:"serial"`
	Comfort   string    `json:"comfort"`
	Available bool      `json:"available"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) SearchCars(ctx context.Context, arg SearchCarsParams) ([]SearchCarsRow, error) {
	rows, err := q.query(ctx, q.searchCarsStmt, searchCars,
		arg.AvailableParam,
		arg.QParam,
		arg.OffsetParam,
		arg.LimitParam,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCarsRow
	for rows.Next() {
		var i SearchCarsRow
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.BrandName,
			&i.Color,
			&i.Serial,
			&i.Comfort,
			&i.Available,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCar = `-- name: UpdateCar :one
UPDATE cars
SET brand_id = $2,
color = $3,
"serial" = $4,
comfort = $5,
available = $6
WHERE id = $1
RETURNING id, brand_id, color, serial, comfort, available, created_at
`

type UpdateCarParams struct {
	ID        int64  `json:"id"`
	BrandID   int64  `json:"brand_id"`
	Color     string `json:"color"`
	Serial    string `json:"serial"`
	Comfort   string `json:"comfort"`
	Available bool   `json:"available"`
}

func (q *Queries) UpdateCar(ctx context.Context, arg UpdateCarParams) (Car, error) {
	row := q.queryRow(ctx, q.updateCarStmt, updateCar,
		arg.ID,
		arg.BrandID,
		arg.Color,
		arg.Serial,
		arg.Comfort,
		arg.Available,
	)
	var i Car
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.Color,
		&i.Serial,
		&i.Comfort,
		&i.Available,
		&i.CreatedAt,
	)
	return i, err
}
